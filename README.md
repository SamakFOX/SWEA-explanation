# SWEA Problem Solving Repository

> **- NOTICE -**
> *This repository contains my personal solutions for SW Expert Academy problems.*  
> **For study and practice purposes only (비상업적 용도).**
>
> **- 안내 -**  
> 이 저장소에는 SWEA의 문제 원문이나 이미지, 테스트 케이스 등 저작권이 있는 자료는 포함되어 있지 않습니다.  
> 문제 번호와 링크만 명시하며, 코드는 본인이 작성한 풀이와 테스트케이스만 포함합니다.

### 파일명 규칙
문제난이도_문제번호_문제명.파일형식 으로 구성되어있습니다. (txt는 테스트케이스입니다)  
```
SWEA-explanation
 └─ java
    ├─ D3_12345_BFS.java = Solution Class
    └─ D3_12345_BFS.txt = Test Case
```
- **문제 출처 : https://swexpertacademy.com/**
---
코딩테스트 대비 + 실력 향상을 위한 문제 풀이 모음입니다.  

※ 이 저장소에 업로드되는 코드가 완벽한 해답은 아닙니다.  
※ 참고용으로만 활용하시기 바랍니다.  

---
&nbsp;
# Core Algorithms

> SW역량 테스트의 경우  
> 1. 적정 알고리즘 사용  
> 2. 문제 해결 사고력  
> 3. 유연한 대응  
> 
> 이 세가지가 중요하다고 생각합니다.
> 알고리즘을 익히고 문제를 풀어보시는 것을 추천드립니다.
>
> ※ 주어진 문제를 이해하고 알고리즘이 필요 없다고 판단되면 본인의 생각대로 푸시면 더 간단히 풀리는 문제도 있습니다.

### 1. 완전탐색 (Brute Force)
주어진 문제에서 **'가능한 모든 경우의 수'** 를 요구하는 경우 생각해보면 좋습니다.  
> 반복문이나 조건문 등 기본함수를 사용해 구현할 수 있지만  
> 경우의 수(처리 데이터량)이 많아질수록 실행시간과 메모리 사용량이 기하급수적으로 증가합니다.  
> 완전탐색의 평균 시간복잡도는 $O(n)$ 또는 $O(n^2)$ 입니다.  
 
순열/조합/부분집합/반복문/중첩반복문을 통해 모든 경우의 수를 탐색할 수 있습니다.  
+백트래킹이나 DFS/BFS를 활용하면 시간복잡도를 줄일 수 있습니다.  

| 유형 | 설명 | 시간복잡도 | SWEA 예시 |
|------|------|-------------|------------|
| **순열 (Permutation)** | n개의 원소를 전부 나열 | **O(n!)** | `최소 이동 거리`, `외판원 순회(TSP)` |
| **조합 (Combination)** | n개 중 r개를 선택 | **O(nCr)** ≈ O(2ⁿ) | `부분집합 합`, `조합으로 만들 수 있는 경우` |
| **부분집합 (Subset)** | 각 원소를 선택 or 비선택 | **O(2ⁿ)** | `부분집합의 합`, `부분집합 나누기 문제` |
| **중첩 반복 완전탐색** | for문으로 모든 경우를 시도 | **O(n²) ~ O(n³)** | `브루트포스 암호`, `부분합`, `쌍 찾기` |
| **순열+백트래킹 (Pruned Permutation)** | 순열 중 불필요한 탐색을 가지치기 | **O(k·n!) (k<1)** | `최적 경로 찾기`, `배열 최소합` |
| **DFS/BFS 완전탐색** | 그래프나 격자 전체 탐색 | **O(V+E)** | `미로 탐색`, `연결 요소 개수`, `단지 번호 붙이기` |

---

### 1.1. 백트래킹 (Backtracking)
- 완전탐색 내에서 '불필요한 경우'를 가지치기(Pruning)하여 탐색량을 줄이는 방식  

### 1.2. BFS/DFS
- BFS (Breadth First Search) : 그래프나 트리에서 한 경로를 끝까지 탐색 후 되돌아가 탐색하는 방식  
- DFS (Depth First Search) : 인접한 노드부터 차례대로 탐색하는 방식  

> 주요 문제) 미로, 섬, 연결 요소  
> 2차원 배열 탐색   
> 그래프·맵 문제 대부분에서 이용 가능  
> 큐/스택 기반 탐색  
> dx, dy 패턴  
> BFS는 deque, DFS는 재귀 이용  
> 방문 여부 관리 (visited 노드 또는 배열)  

### 2. 시뮬레이션, 구현 (Simulation)  
문제에서 '행동'이 주어지고 이를 '시뮬레이션'해야 하는 경우에 생각해보면 좋습니다.  
주어진 규칙을 코드로 작성해야 하고, 설명은 간단해보이지만 생각보다 어렵기 때문에 많이 연습해보시는걸 추천합니다.  

> 주요 문제) 방향 전환, 회전, 로봇 이동, 배열 회전 등  
> 대부분 코딩테스트에서 반드시 출제되는 방식  
> '현재 위치 + 방향'을 상태로 관리  
> 회전, 인덱스 범위, 배열 복사  

### 3. 그리디 (Greedy)  
'최소/최적/구간' 등 선택이 필요한 경우 생각해보면 좋습니다.  
항상 '현재 최적의 해'를 선택해서 결과적으로 전체 최적의 해를 구하는 방식입니다.  

> 주요 문제) 미로, 섬, 연결 요소) 회의실 배정, 동전 거스름돈, 구간 선택, 정렬 응용  
> 항상 '정렬 후 순차 선택' 해야함  

EX) 거스름돈 최소 갯수  
```
10원부터 500원까지 동전이 있고 m원을 거슬러줘야 할 때, 동전의 최소 갯수는?
-> ※ 동전을 최소한으로 쓰려면 최대한 큰 금액으로 m을 감산해야함
-> 1. 동전 배열을 정렬  
-> 2. 반복문을 통해 가장 큰 금액의 동전부터 연산  
-> 3. 갯수 카운트  
```

### 동적 프로그래밍 (Dynamic Programming : DP)
주어진 문제를 '나눠서 처리'해야 하는 경우 생각해보면 좋습니다.  

> 주요 문제)  
> 이전 계산 결과를 재사용  
> 반복되는 연산식을 줄이는게 목적  

EX) 피보나치 수열
```
n에 대한 피보나치값을 출력?  
※ 피보나치(n!)는 n~1을 모두 더한 값  
-> 반복문 이용 결과를 더함 (2~n+1)  
```
### 그래프 (Graph)  
